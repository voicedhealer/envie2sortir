import { AddressData } from '@/components/forms/AdresseStep';
import { EnrichmentData } from '@/lib/enrichment-system';
import { CATEGORIES } from '@/types/establishment-form.types';

// Fonction pour parser l'adresse Google en format formulaire
export function parseAddressFromGoogle(googleAddress: string): AddressData {
  console.log('üè† Parsing adresse Google:', googleAddress);
  
  // Format typique: "44 Rue Monge, 21000 Dijon, France"
  const parts = googleAddress.split(',').map(part => part.trim());
  
  let street = '';
  let postalCode = '';
  let city = '';
  
  if (parts.length >= 3) {
    // Premier √©l√©ment = rue
    street = parts[0];
    
    // Deuxi√®me √©l√©ment = code postal + ville
    const cityPart = parts[1];
    const postalMatch = cityPart.match(/(\d{5})\s+(.+)/);
    if (postalMatch) {
      postalCode = postalMatch[1];
      city = postalMatch[2];
    } else {
      city = cityPart;
    }
  } else if (parts.length === 2) {
    street = parts[0];
    city = parts[1];
  } else {
    street = googleAddress;
  }
  
  const result = { street, postalCode, city };
  console.log('‚úÖ Adresse pars√©e:', result);
  return result;
}

// Fonction pour obtenir les suggestions bas√©es sur les activit√©s
export function getSuggestedTags(activities: string[]): string[] {
  const suggestions: string[] = [];
  
  activities.forEach(activity => {
    // Mapping des activit√©s vers des tags sugg√©r√©s
    const activitySuggestions: { [key: string]: string[] } = {
      'pizzeria': ['pizza', 'italien', 'p√¢tes', 'livraison', 'emporter', 'familial'],
      'restaurant_italien': ['pizza', 'italien', 'p√¢tes', 'antipasti', 'vins', 'familial'],
      'restaurant_fran√ßais': ['fran√ßais', 'traditionnel', 'terroir', 'gastronomique', 'vins'],
      'restaurant_asiatique': ['asiatique', 'sushi', 'wok', 'japonais', 'chinois', 'th√©'],
      'kebab': ['kebab', 'turc', 'sandwich', 'livraison', 'rapide', 'budget'],
      'burger': ['burger', 'am√©ricain', 'frites', 'rapide', 'familial', 'budget'],
      'bar_ambiance': ['cocktails', 'ambiance', 'lounge', 'chic', 'soir√©e', 'romantique'],
      'pub_traditionnel': ['bi√®res', 'pub', 'sport', 'd√©contract√©', 'groupe', 'happy-hour'],
      'brasserie_artisanale': ['bi√®res', 'artisanal', 'local', 'd√©gustation', 'authentique'],
      'bar_cocktails': ['cocktails', 'mixologie', 'sophistiqu√©', 'premium', 'chic'],
      'bar_vins': ['vins', '≈ìnologie', 'd√©gustation', 'raffin√©', 'culturel'],
      'bar_sports': ['sport', 'bi√®res', '√©crans', 'groupe', 'festif', 'happy-hour'],
      'discotheque': ['danse', 'dj', 'musique', 'festif', 'nuit', 'groupe'],
      'club_techno': ['√©lectro', 'techno', 'danse', 'underground', 'nuit'],
      'bowling': ['bowling', 'famille', 'groupe', 'comp√©tition', 'amusant'],
      'escape_game_horreur': ['escape-game', 'aventure', '√©quipe', 'd√©fi', '√©nigme', 'groupe'],
      'futsal': ['football', 'sport', '√©quipe', 'comp√©tition', 'groupe']
    };
    
    if (activitySuggestions[activity]) {
      suggestions.push(...activitySuggestions[activity]);
    }
  });
  
  // Supprimer les doublons et retourner les 15 premiers
  return [...new Set(suggestions)].slice(0, 15);
}

// Fonctions de conversion des tableaux en objets pour compatibilit√© avec ProfessionalData
export function convertAccessibilityArrayToObject(accessibilityArray: string[] = []): any {
  return {
    wheelchairAccessibleEntrance: accessibilityArray.includes('Entr√©e accessible en fauteuil roulant'),
    wheelchairAccessibleParking: accessibilityArray.includes('Parking accessible en fauteuil roulant'),
    wheelchairAccessibleRestroom: accessibilityArray.includes('Toilettes accessibles en fauteuil roulant'),
    wheelchairAccessibleSeating: accessibilityArray.includes('Places assises accessibles en fauteuil roulant')
  };
}

export function convertServicesAvailableArrayToObject(servicesArray: string[] = []): any {
  return {
    delivery: servicesArray.includes('Livraison'),
    takeout: servicesArray.includes('Vente √† emporter'),
    dineIn: servicesArray.includes('Repas sur place')
  };
}

export function convertDiningServicesArrayToObject(diningArray: string[] = []): any {
  return {
    lunch: diningArray.includes('D√©jeuner'),
    dinner: diningArray.includes('D√Æner'),
    catering: diningArray.includes('Traiteur'),
    desserts: diningArray.includes('Desserts'),
    tableService: diningArray.includes('Service √† table')
  };
}

export function convertOfferingsArrayToObject(offeringsArray: string[] = []): any {
  return {
    alcohol: offeringsArray.includes('Alcools'),
    beer: offeringsArray.includes('Bi√®re'),
    coffee: offeringsArray.includes('Caf√©s'),
    cocktails: offeringsArray.includes('Cocktails et ap√©ritifs'),
    vegetarian: offeringsArray.includes('Convient aux v√©g√©tariens'),
    healthyOptions: offeringsArray.includes('Produits sains'),
    spirits: offeringsArray.includes('Spiritueux'),
    wine: offeringsArray.includes('Vin')
  };
}

export function convertAtmosphereArrayToObject(atmosphereArray: string[] = []): any {
  return {
    casual: atmosphereArray.includes('Ambiance d√©contract√©e'),
    cozy: atmosphereArray.includes('Cadre agr√©able'),
    quiet: atmosphereArray.includes('Calme'),
    romantic: atmosphereArray.includes('Romantique'),
    festive: atmosphereArray.includes('Festif')
  };
}

export function convertGeneralServicesArrayToObject(servicesArray: string[] = []): any {
  return {
    wifi: servicesArray.includes('WiFi'),
    airConditioning: servicesArray.includes('Climatisation'),
    restrooms: servicesArray.includes('Toilettes'),
    parking: servicesArray.includes('Parking')
  };
}

// Fonction pour r√©cup√©rer les services et ambiances bas√©s sur les activit√©s s√©lectionn√©es
export const getActivitiesServicesAndAmbiance = (activities: string[]) => {
  if (!activities || activities.length === 0) return null;
  
  // Mapping des activit√©s vers les cat√©gories de services/ambiances
  const activityMappings: Record<string, keyof typeof CATEGORIES> = {
    // Bars
    'bar_ambiance': 'bar',
    'pub_traditionnel': 'bar',
    'brasserie_artisanale': 'bar',
    'bar_cocktails': 'bar',
    'bar_vins': 'bar',
    'bar_sports': 'bar',
    'rooftop_bar': 'bar',
    'bar_karaoke': 'bar',
    'bar_bi√®res': 'bar',
    
    // Restaurants
    'restaurant_gastronomique': 'restaurant',
    'restaurant_traditionnel': 'restaurant',
    'restaurant_familial': 'restaurant',
    'bistrot': 'restaurant',
    'restaurant_italien': 'restaurant',
    'restaurant_asiatique': 'restaurant',
    'restaurant_oriental': 'restaurant',
    'pizzeria': 'restaurant',
    
    // Fast food ‚Üí restaurant pour l'instant
    'kebab': 'restaurant',
    'burger': 'restaurant',
    'tacos_mexicain': 'restaurant',
    
    // Sorties nocturnes
    'discotheque': 'nightclub',
    'club_techno': 'nightclub',
    'boite_nuit_mainstream': 'nightclub',
    
    // Activit√©s
    'escape_game_horreur': 'escape_game',
    'escape_game_aventure': 'escape_game',
    'bowling': 'escape_game', // Temporaire
    
    // Cin√©ma
    'cinema_mainstream': 'cinema',
    
    // Fallback vers les anciennes cat√©gories
    'bar': 'bar',
    'restaurant': 'restaurant',
    'nightclub': 'nightclub',
    'escape_game': 'escape_game',
    'cinema': 'cinema'
  };
  
  // R√©cup√©rer la premi√®re activit√© mapp√©e pour d√©terminer les services/ambiances
  // TODO: Am√©liorer pour fusionner les services de plusieurs activit√©s
  const firstMappedCategory = activityMappings[activities[0]];
  return firstMappedCategory ? CATEGORIES[firstMappedCategory] : null;
};

// Fonction pour convertir un objet de moyens de paiement en tableau
export function convertPaymentMethodsObjectToArray(paymentMethodsObj: any) {
  if (!paymentMethodsObj || typeof paymentMethodsObj !== 'object') return [];
  
  const methods: string[] = [];
  
  if (paymentMethodsObj.creditCards) methods.push('Cartes de cr√©dit');
  if (paymentMethodsObj.debitCards) methods.push('Cartes de d√©bit');
  if (paymentMethodsObj.nfc) methods.push('Paiement mobile NFC');
  if (paymentMethodsObj.cashOnly) methods.push('Esp√®ces uniquement');
  if (paymentMethodsObj.restaurantVouchers) methods.push('Titres restaurant');
  if (paymentMethodsObj.pluxee) methods.push('Pluxee');
  
  return methods;
}

// Fonction pour convertir un tableau de moyens de paiement en objet
export function convertPaymentMethodsArrayToObject(paymentMethodsArray: string[]) {
  const paymentMethodsObj: any = {};
  
  paymentMethodsArray.forEach(method => {
    const methodLower = method.toLowerCase();
    
    // Cartes bancaires
    if (methodLower.includes('carte') && (methodLower.includes('cr√©dit') || methodLower.includes('credit'))) {
      paymentMethodsObj.creditCards = true;
    }
    if (methodLower.includes('carte') && methodLower.includes('d√©bit')) {
      paymentMethodsObj.debitCards = true;
    }
    
    // Paiements mobiles
    if (methodLower.includes('nfc') || methodLower.includes('mobile')) {
      paymentMethodsObj.nfc = true;
    }
    
    // Esp√®ces
    if (methodLower.includes('esp√®ces') || methodLower.includes('cash')) {
      paymentMethodsObj.cashOnly = true;
    }
    
    // Titres restaurant
    if (methodLower.includes('titre') || methodLower.includes('restaurant')) {
      paymentMethodsObj.restaurantVouchers = true;
    }
    
    // Pluxee
    if (methodLower.includes('pluxee')) {
      paymentMethodsObj.pluxee = true;
    }
    
    // Pour les autres moyens non reconnus, on les ajoute comme propri√©t√©s bool√©ennes
    if (!paymentMethodsObj.creditCards && !paymentMethodsObj.debitCards && 
        !paymentMethodsObj.nfc && !paymentMethodsObj.cashOnly && 
        !paymentMethodsObj.restaurantVouchers && !paymentMethodsObj.pluxee) {
      paymentMethodsObj[methodLower.replace(/\s+/g, '')] = true;
    }
  });
  
  return paymentMethodsObj;
}

// Fonction pour parser l'adresse compl√®te en mode √©dition
export function parseAddress(fullAddress: string) {
  if (!fullAddress) return { street: "", postalCode: "", city: "" };
  
  // Pattern pour extraire : "8 Pl. Raspail, 69007 Lyon"
  const match = fullAddress.match(/^(.+?),\s*(\d{5})\s+(.+)$/);
  if (match) {
    return {
      street: match[1].trim(),
      postalCode: match[2].trim(),
      city: match[3].trim()
    };
  }
  
  // Si le pattern ne correspond pas, essayer de s√©parer par virgule
  const parts = fullAddress.split(',').map(p => p.trim());
  if (parts.length >= 3) {
    return {
      street: parts[0],
      postalCode: parts[1],
      city: parts[2]
    };
  }
  
  // Fallback : tout dans street
  return {
    street: fullAddress,
    postalCode: "",
    city: ""
  };
}

// Fonction pour valider un num√©ro de t√©l√©phone mobile fran√ßais (06 ou 07)
export function isValidFrenchPhone(phone: string): boolean {
  const cleanPhone = phone.replace(/\s/g, '').replace(/[^\d+]/g, '');
  // Accepter seulement les num√©ros mobiles : 06, 07, +336, +337
  return /^(0[67]|\+33[67])[0-9]{8}$/.test(cleanPhone);
}

// Fonction pour d√©terminer l'√©tat visuel du champ t√©l√©phone
export function getPhoneFieldState(phone: string, isVerified: boolean): {
  state: 'empty' | 'invalid' | 'valid' | 'verified';
  className: string;
  message: string;
  disabled: boolean;
} {
  const cleanPhone = phone.replace(/\s/g, '').replace(/[^\d+]/g, '');
  
  // Si v√©rifi√©, √©tat final
  if (isVerified && phone) {
    return {
      state: 'verified',
      className: 'border-green-500 bg-green-50',
      message: '‚úì Num√©ro de t√©l√©phone v√©rifi√©',
      disabled: true
    };
  }
  
  // Si vide, √©tat initial
  if (!phone || cleanPhone.length === 0) {
    return {
      state: 'empty',
      className: 'border-gray-300',
      message: 'üì± Un SMS de v√©rification sera envoy√© √† ce num√©ro mobile (06 ou 07 uniquement)',
      disabled: false
    };
  }
  
  // V√©rifier si c'est un num√©ro mobile valide (06 ou 07 + 10 chiffres)
  const isValidMobile = /^(0[67]|\+33[67])[0-9]{8}$/.test(cleanPhone);
  
  if (isValidMobile) {
    return {
      state: 'valid',
      className: 'border-green-500 bg-green-50',
      message: 'üì± Envoi automatique du SMS en cours...',
      disabled: true
    };
  }
  
  // V√©rifier si le num√©ro commence par des pr√©fixes invalides (01-05, 08-09)
  const startsWithInvalidPrefix = /^(0[1-5]|0[8-9])/.test(cleanPhone);
  
  if (startsWithInvalidPrefix) {
    return {
      state: 'invalid',
      className: 'border-red-300 bg-red-50',
      message: '‚ö†Ô∏è Num√©ro invalide : Le num√©ro doit commencer par 06 ou 07 et contenir 10 chiffres',
      disabled: false
    };
  }
  
  // Si commence par 06 ou 07 mais n'a pas encore 10 chiffres, √©tat neutre
  const startsWithValidPrefix = /^(0[67]|\+33[67])/.test(cleanPhone);
  
  if (startsWithValidPrefix) {
    return {
      state: 'empty',
      className: 'border-gray-300',
      message: 'üì± Un SMS de v√©rification sera envoy√© √† ce num√©ro mobile (06 ou 07 uniquement)',
      disabled: false
    };
  }
  
  // Sinon, invalide (autres cas)
  return {
    state: 'invalid',
    className: 'border-red-300 bg-red-50',
    message: '‚ö†Ô∏è Num√©ro invalide : Le num√©ro doit commencer par 06 ou 07 et contenir 10 chiffres',
    disabled: false
  };
}

// Fonction pour valider un email
export function isValidEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

// Fonction pour valider un mot de passe s√©curis√©
export function isValidPassword(password: string): {
  isValid: boolean;
  errors: string[];
} {
  const errors: string[] = [];
  
  // V√©rifier la longueur minimale
  if (password.length < 8) {
    errors.push("Au moins 8 caract√®res");
  }
  
  // V√©rifier au moins 2 chiffres
  const digitCount = (password.match(/\d/g) || []).length;
  if (digitCount < 2) {
    errors.push("Au moins 2 chiffres");
  }
  
  // V√©rifier au moins une majuscule
  if (!/[A-Z]/.test(password)) {
    errors.push("Au moins une majuscule");
  }
  
  // V√©rifier au moins un caract√®re sp√©cial
  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
    errors.push("Au moins un caract√®re sp√©cial (!@#$%^&*...)");
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

// Fonction pour valider un SIRET
export function isValidSiret(siret: string): boolean {
  return siret.length === 14 && /^\d{14}$/.test(siret);
}
